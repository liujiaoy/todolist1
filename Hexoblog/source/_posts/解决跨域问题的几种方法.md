---
title: 解决跨域问题的几种方法
date: 2021-08-23 16:38:23
top_img: topimg.png
cover: topimg.png
tags:
    - 知识点
catagories:
    - code
---

## 前言

昨天晚上刷面试视频看到这个问题了，解决跨域的几种方法，其实算个老问题了，不少文章都讲到过，看了好几篇，一直没动手记录，因为感觉没闹懂，直到昨天终于感觉有点悟了。
赶紧来尝试记录一下，看自己能不能解释清楚。

## JSONP

这应该是最早的一种方式解决跨域，通过\<script\>标签来处理，原理就是利用script标签没有跨域的概念，就像我们通过cdn来引用在线js文件一样，不会有跨域问题。

### 方式

```js
//本质是这样，但这种只能写死的肯定不行
<script type="text/javascript" src="../js/SheetOut/SheetOutPopUp.js?t=20210826"></script>
//所以需要写成方法
 <script>
    var script = document.createElement('script');//创建script标签
    script.type = 'text/javascript';//类型

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'; 
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

这个需要后台支持，写对应的方法
缺点: 
1. 它只支持GET请求而不支持POST等其它类型的HTTP请求
2. 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
3. jsonp在调用失败的时候不会返回各种HTTP状态码。
4. 缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个 jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的

## iframe跨域 （感觉很不清晰）

iframe标签src可以跨域

### 主域相同

document.domain 此方案仅限主域相同，子域不同的跨域应用场景。
原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

### 主域不同

1. location.hash
原理：利用location.hash来进行传值,A通过location.hash方式传递参数给B，B通过定时器检测hash变化，执行对应操作，将数据通过location.hash传给C,C与A同域可访问A页面所有对象。

location.hash缺点
- 传递数据量有限
- 不太安全

2. window.name + iframe跨域

[一个讲的比较明白的博客](https://www.cnblogs.com/RuMengkai/p/6801820.html)

原理：name 值在不同的页面（甚至不同域名）加载后依旧存在
- A.com/A.html想发送请求给B.com/B.html,
- A.html通过创建iframe src = B.com/B.html进行请求
- B.html通过设置name返回数据
``` php
<?php
  echo '<script> window.name = "{\"name\":\"hanzichi\", \"age\":10}"; </script>'
?>
```
- 改变A.html的src = A.com/C.html,因为如果页面与iframe src不同源返回了数据也不能操作

window.name 优势： name 值长（2MB）

3. postMessage

这里用代码来说明

- 1)a.com/index.html中的代码：
``` js
<iframe id="ifr" src="b.com/index.html"></iframe>
<script type="text/javascript">
window.onload = function() {
    var ifr = document.getElementById('ifr');
    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样
                                        // 若写成'http://c.com'就不会执行postMessage了
    ifr.contentWindow.postMessage('I was there!', targetOrigin);
};
</script>
```
- 2)b.com/index.html中的代码：
``` js
<script type="text/javascript">
    window.addEventListener('message', function(event){
        // 通过origin属性判断消息来源地址
        if (event.origin == 'http://a.com') {
            alert(event.data);    // 弹出"I was there!"
            alert(event.source);  // 对a.com、index.html中window对象的引用
                                  // 但由于同源策略，这里event.source不可以访问window对象
        }
    }, false);
</script>
```

## CORS

主要工作实在后台
跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器「不同的域、协议或端口」请求一个资源时，资源会发起一个「跨域 HTTP 请求」。
缺点：兼容性存在问题

CORS请求分为两类:简单请求和非简单请求
满足以下两个条件为简单请求
1)请求方法是以下三种方法之一：
- HEAD
- GET
- POST

2)HTTP的头信息不超出以下几种字段：
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
不满足为非简单请求

## nginx反向代理

反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。

这个现在比较常用,其实就是下载nginx代理进行相关配置就行
具体的配置等会去用个例子尝试以下，不然还是记不住