---
title: 前端面试题记录
date: 2021-08-17 09:40:55
top_img: topimg.png
cover: topimg.png
tags: 
    - 知识点
categories:
    - code
---

## 发现刷面试题也是巩固知识的一个好方法，好记性不如烂笔头

所有的代码例子还是要自己敲一遍，跑一边才能更理解。
概念性的东西要多尝试讲给别人听，看自己能不能讲通。
同时引申去思考一些东西，为什么问这些问题，在哪些场景能用上，自己可不可以去造一些例子......

## CSS部分

### 垂直居中

高频问题
基本所有前端开发者都会遇到，日常常见问题，算一个基础问题，然后还能引申到flex布局上，面试上也很好切换问题方向
实现方式分几种

#### 1. 基于定位

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #outBox{
      position: relative;
      width: 100%;
      height: 400px;
      background:aqua;
      overflow: auto;
    }
    /* 方法一 必须知道需要居中的box的宽度 */
    #centerBox{
      position: absolute;
      background-color: red;
      width:100px;
      height: 100px;
      top:50%;
      left: 50%;
      margin-top: -50px;
      margin-left: -50px;
    }
    /* 方法二  可以不用知道需要居中的box的宽高，但兼容性不好 */
    #centerBox{
      position: absolute;
      background-color: red;
      top:50%;
      left: 50%;
      transform: translate(-50%,-50%);
    }
    /* 方法三 还是必须需要居中的box有宽高 */
    #centerBox{
      position: absolute;
      background-color: red;
      width:100px;
      height: 100px;
      top:0;
      left: 0;
      bottom: 0;
      right: 0;
      margin: auto;  
    }

  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
</html>
```

#### 2. 通过js

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #outBox{
      position: relative;
      width: 100%;
      height: 400px;
      background:aqua;
      overflow: auto;
    }
    #centerBox{
      position: absolute;
      background-color: red; 
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
<script type="text/javascript">
 window.onload = function(){
    let outBox = document.getElementById("outBox"),
        outBoxH = outBox.offsetHeight,
        outBoxW = outBox.offsetWidth,
        centerBox = document.getElementById("centerBox"),
        centerBoxH =centerBox.offsetHeight,
        centerBoxW = centerBox.offsetWidth;
    centerBox.style.marginLeft = (outBoxW-centerBoxW)/2 + "px";
    centerBox.style.marginTop = (outBoxH-centerBoxH)/2 + "px";
  }
</script>
</html>
</script>
```

#### 3. flex布局

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #centerBox{
      background-color: red; 
    }
    /*最简单，但也是兼容性问题*/
    #outBox{
      display: flex;
      justify-content: center;
      align-items: center;
      width: 800px;
      height: 400px;
      background:aqua;
    } 
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
</html>
```

### 清除浮动

float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反）。

#### 1. 触发BFC 即外层div增加属性overflow：hidden(除visible之外的属性)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
  /* 方法一 */
    #outBox{
      background-color:aqua;
      width: 400px;
      overflow: hidden;
    }
    #centerBox{
      float: left;
      background-color: red;
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
</html>
```

#### 2. 额外增加标签并设置clear:both

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
  /* 方法一 */
    #outBox{
      background-color:aqua;
      width: 400px;
    }
    #centerBox{
      float: left;
      background-color: red;
    }
    .for-clear-float{
      clear: both;
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
    <div class="for-clear-float"></div>
  </div>
</body>
</html>
```

#### 3. 增加after伪元素

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
  /* 方法一 */
    #outBox{
      background-color:aqua;
      width: 400px;
    }
    #centerBox{
      float: left;
      background-color: red;
    }
    .clear{
      *zoom: 1;
    }
    /*加在父div上*/
    .clear:after{
      content: "";
      display: block;
      clear: both;
      height: 0;
      visibility: hidden;
    }

  </style>
</head>
<body>
  <div id="outBox" class="clear">
    <div id="centerBox" >一个三四五</div>
  </div>
</body>
</html>
```

#### 4. 引申思考

1）既然会有高度塌陷问题，那为什么要用float，他干什么用的

float设计用来做文字环绕效果，这也是他出现高度塌陷的原因，只有高度塌陷了才好实现文字环绕效果
具体可以查看博客[CSS布局(四) float详解](https://www.cnblogs.com/duw76/p/10042999.html)


### 关于BFC

这个问题可以穿插到清除浮动时问。
对于BFC，感觉是知其然而不知其所以然，只了解基本概念，比如全称是Block Formatting Context（块格式化上下文），可以清除浮动。
却没有详细去了解，今天查看了一下才有一种恍然大悟的感觉

[参考博客地址](https://www.cnblogs.com/qs-cnblogs/p/12349887.html)
[MDN文档地址](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)
BFC的特性
1、属于同一个BFC的两个相邻容器的上下margin会重叠（重点）
2、计算BFC高度时浮动元素也参于计算（重点）
3、BFC的区域不会与浮动容器发生重叠（重点）
4、BFC内的容器在垂直方向依次排列
5、元素的margin-left与其包含块的border-left相接触
6、BFC是独立容器，容器内部元素不会影响容器外部元素

BFC的触发条件
1、根元素（html）
2、float值非none
3、overflow值非visible
4、display值为inline-block、table-cell、table-caption、flex、inline-flex
5、position值为absolute、fixed

在验证margin重叠问题时，以下情况会出现margin重叠

```html
<body>

    <div class="boxa">
      boxa
    </div>
    <div class="boxb">
      boxb
    </div>
  
</body>
```
```css
.boxa,.boxb{
  margin: 20px;
  height: 20px;

}
.boxa{
  background-color: aqua;
  overflow: hidden;

}
.boxb{
  background-color: bisque;
}
```
![图片](3-BFC-margin.png)
此时我想我触发boxa BFC应该就可以了，然后我在boxa 上添加属性overflow:hidden后没有效果，具体也没查到这个问题，
其余博客都是说在boxa外层再加一个div，这个div触发BFC即可。我试了确实成功了...困惑了很久
现在我猜测的是根元素是BFC，所以boxa，boxb属于同一个BFC，即使boxa触发了BFC，他们也还是同一个BFC
只要再boxa外层在套一个div触发BFC，boxa和boxb才处于不同的BFC。。。
但是我通过设置boxa为inline-block来触发BFC，margin又不重叠了...........这下我真的迷惑了，继续找结果，最后在知乎找到了
直接放图片了 ![关于margin重叠](3-margin-collapse.png)

### 介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同

标准盒模型 content 的宽高为元素的width ，height，一个块的总宽 =  width + padding +border +margin;
IE盒模型 content + padding + border 才是元素的width，height，一个块的总宽 =  width + margin;
通常开发中，用的多的是IE盒模型

### css3新特性

#### 1. 动画 animation

  animation是个缩写属性，包含以下六个属性 默认none 0 ease 0 1 normal
  animation-name: keyframe 名称
  animation-duration: 完成动画时间
  animation-timing-function: 规定动画的速度曲线
  animation-delay: 动画开始之前的延迟
  animation-iteration-count: 规定动画应该播放的次数
  animation-direction: 规定是否应该轮流反向播放动画
  例子：实现一个简单的音乐震动条吧

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
    #outBox{
      background-color:aqua;
      width: 800px;
      height:400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #centerBox{
      height: 100px;
      width: 100px;
    }
    #wave{
      height: 100%;
      width: 100%;
      display: flex;
      /* flex-direction: column; */
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-end;
      padding: 0;
      margin: 0;
    }
    #wave li{
      list-style-type:none;
      height: 0;
      width: 15px;
      background-color: brown;
      margin: 0 2px;
    }
    #centerBox #wave .li1{
      animation: waves .8s linear 1s infinite alternate;//名字  时间   方式  延迟  次数   重复
    }
    #wave .li2{
      animation: waves 1s linear .2s infinite alternate;
    }
    #wave .li3{
      animation: waves 2s linear .5s infinite alternate;
    }
    #wave .li4{
      animation: waves 1s linear .5s infinite alternate;
    }
    #wave .li5{
      animation: waves 1.5s linear .5s infinite alternate;
    }
    @keyframes waves{
      10% {
        height:20%
      }
      20%{
        height:60%
      }
      40% {
        height:40%
      }
      50% {
        height:100%
      }
      100%{
        height: 50%;
      }
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">
      <ul id="wave">
        <li class="li1"></li>
        <li class="li2"></li>
        <li class="li3"></li>
        <li class="li4"></li>
        <li class="li5"></li>
      </ul>
    </div>
  </div>
</body>
</html>
```

#### 2. 过渡 transition

  transition: css属性，花费时间，曲线效果，延迟时间(默认0)
  引用W3C的例子，鼠标放上去出效果

  ```html
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
    #outBox{
      background-color:aqua;
      width: 800px;
      height:400px;
    }
    #centerBox{
      float: left;
      background-color: red;
      width: 100px;
    }

    /* transition过渡效果 */
    #centerBox:hover{
      width:300px;
      transition: width,.5s,linear,2s;
    } 
  </style>
</head>
<body>
  <div id="outBox" class="clear">
    <div id="centerBox" >鼠标放上来</div>
  </div>
</body>
</html>
  ```

#### 3. 形状转换

translate前面的垂直居中用到过
rotate 旋转
做一个导航栏悬浮箭头旋转90度的案例，这里设计到自己用css画三角形

1)css画三角形，利用border实现

```html
<div id="triangle-up"></div>
<div id="triangle-down"></div>
<div id="triangle-right"></div>
<div id="triangle-left"></div>
```

```css
/* 实现三角形 */
    #triangle-up {
      width: 0;
      height: 0;
      /* 构造三条边 */
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 100px solid red;
    }

    #triangle-down {
      width: 0;
      height: 0;
      /* 构造三条边 */
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-top: 100px solid blue;
    }
    #triangle-left{
      width: 0;
      height: 0;
      /* 构造三条边 */
      border-top: 50px solid transparent;
      border-bottom: 50px solid transparent;
      border-right: 100px solid green;
    }
    #triangle-right{
      width: 0;
      height: 0;
      /* 构造三条边 */
      border-top: 50px solid transparent;
      border-bottom: 50px solid transparent;
      border-left: 100px solid pink;
    }
```

2)导航栏案例

```html
<div id="nav">
  <ul>
    <li class="title" id="title">
      <span>一级标题</span><span class="triangle-right"></span>
      <ul class="sub-title" >
        <li>二级标题</li>
        <li>二级标题</li>
        <li>二级标题</li>
      </ul>
    </li>
  </ul>
  </div>
  
```

```css
.title{
      position: relative;
    }
    .triangle-right{
      position: absolute;
      top:6px;
      width: 0;
      height: 0;
      /* 构造三条边 */
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 10px solid pink;
    }
    .sub-title{
      visibility: hidden;
      opacity: 0;
    }
    #title:hover .sub-title{
      visibility: visible;
      opacity: 1;
      transition: opacity,3s,linear,2s;
    }
    #title:hover .triangle-right{
      transform: rotate(90deg);
      transition: all,.5s,ease,1s;
    }
```

#### 搜罗了一下有点多，移步博客（？）

### 待续...

## JS部分

### js数据类型

6大数据类型
五种基本数据类型 Number,Null,Undefined,Boolean,String
一种复杂数据类型 Object
es6 新加入 symbol

谈到ES6，就想到下面的问题了

### ES6新特性

[阮一峰的博客](https://es6.ruanyifeng.com/)
  
#### const和let
  const:只读常量
    const 对象之能使对象的地址不变，对象里面的值控制不了
  let:局部变量
    1）只在当前代码块有效
    2）不会出现变量提升
    3）存在暂时性死区
    4）不允许重复声明

#### 变量的解构赋值

  形如 let [a,b] = [1,2]
  解构赋值允许指定默认值
  let[x,y='2'] = [1]

  let a =10,b=20;
  [a,b] = [b,a]

#### 模板字面量
#### for...of
#### 展开运算符
#### 剩余参数(可变参数)
#### ES6箭头函数
#### 默认参数函数
#### 默认值与解构
#### Javascript类
#### super 和 extends

### null与undefined

null 为 对象压根不存在,undefined 更像是存在但无值

### 判断数据类型的方法

一.typeof，
优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object
注意！ typeof(null)//object 但typeof 可以检测function

二.instanceof
可进一步区分object为对象还是数组还是函数
优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断

三、Object.prototype.toString.call()

```js
var toString = Object.prototype.toString;
 
console.log(toString.call(1));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('abc'));                  //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(function(){}));           //[object Function]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
```

优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用 

### 原生ajax

其实很简单
1.创建xhr(xmlhttprequest)对象
2.请求参数，url ，类型，参数等
3.发送请求
4.监听回调xhr.onreadystatechange,说明请求完成

```js
//步骤一:创建异步对象
var ajax = new XMLHttpRequest();
//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
ajax.open('get','getStar.php?starName='+name);
//步骤三:发送请求
ajax.send();
//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {   if (ajax.readyState==4 &&ajax.status==200) {
    //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的　　　　console.log(ajax.responseText);//输入相应的内容  　　}
}
```


### 对象深浅拷贝

#### 浅拷贝

一.object.assign(target,souce)//Object.assign({},{a:1,b:2})

二.手动实现
自己实现也很简单，就一个for循环进行赋值

```javascript
function simpleClone(obj) {
    var result = {};
    for (var i in obj) {
        result[i] = obj[i];
    }
    return result;
}
```

#### 深拷贝

一.json.parse(json.stringfy(obj))
二.手动实现
也没想象中难，就用递归把所有属性都复制下来,但是其中有比较多的细节可以注意

```javascript
function deepClone(obj) {
    var result = {};
    for (var i in obj) {
        if(typeof obj[i] === "object"){
             result[i] = deepClone(obj[i])
        }else{
            result[i] = obj[i];
        }
        
    }
    return result;
}

function deepCopyTwo(obj) {
    let objClone = Array.isArray(obj) ? [] : {};
    if (obj && typeof obj == 'object') {
        for (const key in obj) {
            //判断obj子元素是否为对象，如果是，递归复制
            if (obj[key] && typeof obj[key] === "object") {
                objClone[key] = deepCopyTwo(obj[key]);
            } else {
                //如果不是，简单复制
                objClone[key] = obj[key];
            }
        }
    }
    return objClone;
}

```

### this指向问题

### 数组去重的几种方式

### 数组扁平化

### 类数组转化为数组

### 防抖节流

### 闭包

### 跨域问题

我觉得这个问题挺大的，另开一篇文来写吧

### 原型链相关

### 继承

### ajax相关

### 事件委托

### 输入url之后，到底发生了什么？

这个问题，很眼熟吧，但是记不住，亏我之前还是网络专业的

1.DNS解析
2.建立TCP连接 
  三次握手 
  ![tcp.jpg](三次握手)
  第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认
  第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态
  第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手
3.发送http请求
4.接收响应结果
5.解析html
6.渲染

 ![输入url之后，到底发生了什么](url.png)

### http与https

二者区别：https安全性较高

> HTTP 与 HTTPS 区别
  HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
  使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
  HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
  http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
  HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。
  https = http + ssl
  https对传输数据进行加密处理
  
HTTPS 的工作原理
 ![HTTPS 的工作原理](https-intro.png)

### 重排与重绘
